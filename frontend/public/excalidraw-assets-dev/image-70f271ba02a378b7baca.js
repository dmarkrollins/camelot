"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkExcalidraw"] = globalThis["webpackChunkExcalidraw"] || []).push([["image"],{

/***/ "../../data/encode.ts":
/*!****************************!*\
  !*** ../../data/encode.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toByteString\": () => (/* binding */ toByteString),\n/* harmony export */   \"stringToBase64\": () => (/* binding */ stringToBase64),\n/* harmony export */   \"base64ToString\": () => (/* binding */ base64ToString),\n/* harmony export */   \"encode\": () => (/* binding */ encode),\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"compressData\": () => (/* binding */ compressData),\n/* harmony export */   \"decompressData\": () => (/* binding */ decompressData)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"../../../node_modules/pako/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./encryption */ \"../../data/encryption.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n// -----------------------------------------------------------------------------\n// byte (binary) strings\n// -----------------------------------------------------------------------------\n// fast, Buffer-compatible implem\nconst toByteString = (data) => {\n    return new Promise((resolve, reject) => {\n        const blob = typeof data === \"string\"\n            ? new Blob([new TextEncoder().encode(data)])\n            : new Blob([data instanceof Uint8Array ? data : new Uint8Array(data)]);\n        const reader = new FileReader();\n        reader.onload = (event) => {\n            if (!event.target || typeof event.target.result !== \"string\") {\n                return reject(new Error(\"couldn't convert to byte string\"));\n            }\n            resolve(event.target.result);\n        };\n        reader.readAsBinaryString(blob);\n    });\n};\nconst byteStringToArrayBuffer = (byteString) => {\n    const buffer = new ArrayBuffer(byteString.length);\n    const bufferView = new Uint8Array(buffer);\n    for (let i = 0, len = byteString.length; i < len; i++) {\n        bufferView[i] = byteString.charCodeAt(i);\n    }\n    return buffer;\n};\nconst byteStringToString = (byteString) => {\n    return new TextDecoder(\"utf-8\").decode(byteStringToArrayBuffer(byteString));\n};\n// -----------------------------------------------------------------------------\n// base64\n// -----------------------------------------------------------------------------\n/**\n * @param isByteString set to true if already byte string to prevent bloat\n *  due to reencoding\n */\nconst stringToBase64 = (str, isByteString = false) => __awaiter(void 0, void 0, void 0, function* () {\n    return isByteString ? window.btoa(str) : window.btoa(yield toByteString(str));\n});\n// async to align with stringToBase64\nconst base64ToString = (base64, isByteString = false) => __awaiter(void 0, void 0, void 0, function* () {\n    return isByteString\n        ? window.atob(base64)\n        : byteStringToString(window.atob(base64));\n});\n/**\n * Encodes (and potentially compresses via zlib) text to byte string\n */\nconst encode = ({ text, compress, }) => __awaiter(void 0, void 0, void 0, function* () {\n    let deflated;\n    if (compress !== false) {\n        try {\n            deflated = yield toByteString((0,pako__WEBPACK_IMPORTED_MODULE_0__.deflate)(text));\n        }\n        catch (error) {\n            console.error(\"encode: cannot deflate\", error);\n        }\n    }\n    return {\n        version: \"1\",\n        encoding: \"bstring\",\n        compressed: !!deflated,\n        encoded: deflated || (yield toByteString(text)),\n    };\n});\nconst decode = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    let decoded;\n    switch (data.encoding) {\n        case \"bstring\":\n            // if compressed, do not double decode the bstring\n            decoded = data.compressed\n                ? data.encoded\n                : yield byteStringToString(data.encoded);\n            break;\n        default:\n            throw new Error(`decode: unknown encoding \"${data.encoding}\"`);\n    }\n    if (data.compressed) {\n        return (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflate)(new Uint8Array(byteStringToArrayBuffer(decoded)), {\n            to: \"string\",\n        });\n    }\n    return decoded;\n});\n// -----------------------------------------------------------------------------\nconst CONCAT_BUFFERS_VERSION = 1;\n/** how many bytes we use to encode how many bytes the next chunk has.\n * Corresponds to DataView setter methods (setUint32, setUint16, etc).\n *\n * NOTE ! values must not be changed, which would be backwards incompatible !\n */\nconst VERSION_DATAVIEW_BYTES = 4;\nconst NEXT_CHUNK_SIZE_DATAVIEW_BYTES = 4;\n// -----------------------------------------------------------------------------\nconst DATA_VIEW_BITS_MAP = { 1: 8, 2: 16, 4: 32 };\n/**\n * abstraction over DataView that serves as a typed getter/setter in case\n * you're using constants for the byte size and want to ensure there's no\n * discrepenancy in the encoding across refactors.\n *\n * DataView serves for an endian-agnostic handling of numbers in ArrayBuffers.\n */\nfunction dataView(buffer, bytes, offset, value) {\n    if (value != null) {\n        if (value > Math.pow(2, DATA_VIEW_BITS_MAP[bytes]) - 1) {\n            throw new Error(`attempting to set value higher than the allocated bytes (value: ${value}, bytes: ${bytes})`);\n        }\n        const method = `setUint${DATA_VIEW_BITS_MAP[bytes]}`;\n        new DataView(buffer.buffer)[method](offset, value);\n        return buffer;\n    }\n    const method = `getUint${DATA_VIEW_BITS_MAP[bytes]}`;\n    return new DataView(buffer.buffer)[method](offset);\n}\n// -----------------------------------------------------------------------------\n/**\n * Resulting concatenated buffer has this format:\n *\n * [\n *   VERSION chunk (4 bytes)\n *   LENGTH chunk 1 (4 bytes)\n *   DATA chunk 1 (up to 2^32 bits)\n *   LENGTH chunk 2 (4 bytes)\n *   DATA chunk 2 (up to 2^32 bits)\n *   ...\n * ]\n *\n * @param buffers each buffer (chunk) must be at most 2^32 bits large (~4GB)\n */\nconst concatBuffers = (...buffers) => {\n    const bufferView = new Uint8Array(VERSION_DATAVIEW_BYTES +\n        NEXT_CHUNK_SIZE_DATAVIEW_BYTES * buffers.length +\n        buffers.reduce((acc, buffer) => acc + buffer.byteLength, 0));\n    let cursor = 0;\n    // as the first chunk we'll encode the version for backwards compatibility\n    dataView(bufferView, VERSION_DATAVIEW_BYTES, cursor, CONCAT_BUFFERS_VERSION);\n    cursor += VERSION_DATAVIEW_BYTES;\n    for (const buffer of buffers) {\n        dataView(bufferView, NEXT_CHUNK_SIZE_DATAVIEW_BYTES, cursor, buffer.byteLength);\n        cursor += NEXT_CHUNK_SIZE_DATAVIEW_BYTES;\n        bufferView.set(buffer, cursor);\n        cursor += buffer.byteLength;\n    }\n    return bufferView;\n};\n/** can only be used on buffers created via `concatBuffers()` */\nconst splitBuffers = (concatenatedBuffer) => {\n    const buffers = [];\n    let cursor = 0;\n    // first chunk is the version\n    const version = dataView(concatenatedBuffer, NEXT_CHUNK_SIZE_DATAVIEW_BYTES, cursor);\n    // If version is outside of the supported versions, throw an error.\n    // This usually means the buffer wasn't encoded using this API, so we'd only\n    // waste compute.\n    if (version > CONCAT_BUFFERS_VERSION) {\n        throw new Error(`invalid version ${version}`);\n    }\n    cursor += VERSION_DATAVIEW_BYTES;\n    while (true) {\n        const chunkSize = dataView(concatenatedBuffer, NEXT_CHUNK_SIZE_DATAVIEW_BYTES, cursor);\n        cursor += NEXT_CHUNK_SIZE_DATAVIEW_BYTES;\n        buffers.push(concatenatedBuffer.slice(cursor, cursor + chunkSize));\n        cursor += chunkSize;\n        if (cursor >= concatenatedBuffer.byteLength) {\n            break;\n        }\n    }\n    return buffers;\n};\n// helpers for (de)compressing data with JSON metadata including encryption\n// -----------------------------------------------------------------------------\n/** @private */\nconst _encryptAndCompress = (data, encryptionKey) => __awaiter(void 0, void 0, void 0, function* () {\n    const { encryptedBuffer, iv } = yield (0,_encryption__WEBPACK_IMPORTED_MODULE_1__.encryptData)(encryptionKey, (0,pako__WEBPACK_IMPORTED_MODULE_0__.deflate)(data));\n    return { iv, buffer: new Uint8Array(encryptedBuffer) };\n});\n/**\n * The returned buffer has following format:\n * `[]` refers to a buffers wrapper (see `concatBuffers`)\n *\n * [\n *   encodingMetadataBuffer,\n *   iv,\n *   [\n *      contentsMetadataBuffer\n *      contentsBuffer\n *   ]\n * ]\n */\nconst compressData = (dataBuffer, options) => __awaiter(void 0, void 0, void 0, function* () {\n    const fileInfo = {\n        version: 2,\n        compression: \"pako@1\",\n        encryption: \"AES-GCM\",\n    };\n    const encodingMetadataBuffer = new TextEncoder().encode(JSON.stringify(fileInfo));\n    const contentsMetadataBuffer = new TextEncoder().encode(JSON.stringify(options.metadata || null));\n    const { iv, buffer } = yield _encryptAndCompress(concatBuffers(contentsMetadataBuffer, dataBuffer), options.encryptionKey);\n    return concatBuffers(encodingMetadataBuffer, iv, buffer);\n});\n/** @private */\nconst _decryptAndDecompress = (iv, decryptedBuffer, decryptionKey, isCompressed) => __awaiter(void 0, void 0, void 0, function* () {\n    decryptedBuffer = new Uint8Array(yield (0,_encryption__WEBPACK_IMPORTED_MODULE_1__.decryptData)(iv, decryptedBuffer, decryptionKey));\n    if (isCompressed) {\n        return (0,pako__WEBPACK_IMPORTED_MODULE_0__.inflate)(decryptedBuffer);\n    }\n    return decryptedBuffer;\n});\nconst decompressData = (bufferView, options) => __awaiter(void 0, void 0, void 0, function* () {\n    // first chunk is encoding metadata (ignored for now)\n    const [encodingMetadataBuffer, iv, buffer] = splitBuffers(bufferView);\n    const encodingMetadata = JSON.parse(new TextDecoder().decode(encodingMetadataBuffer));\n    try {\n        const [contentsMetadataBuffer, contentsBuffer] = splitBuffers(yield _decryptAndDecompress(iv, buffer, options.decryptionKey, !!encodingMetadata.compression));\n        const metadata = JSON.parse(new TextDecoder().decode(contentsMetadataBuffer));\n        return {\n            /** metadata source is always JSON so we can decode it here */\n            metadata,\n            /** data can be anything so the caller must decode it */\n            data: contentsBuffer,\n        };\n    }\n    catch (error) {\n        console.error(`Error during decompressing and decrypting the file.`, encodingMetadata);\n        throw error;\n    }\n});\n// -----------------------------------------------------------------------------\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUssQ0FDbkQsSUFBSSxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsc0JBQXNCLENBQUMsQ0FDakQsQ0FBQztJQUVGLElBQUk7UUFDRixNQUFNLENBQUMsc0JBQXNCLEVBQUUsY0FBYyxDQUFDLEdBQUcsWUFBWSxDQUMzRCxNQUFNLHFCQUFxQixDQUN6QixFQUFFLEVBQ0YsTUFBTSxFQUNOLE9BQU8sQ0FBQyxhQUFhLEVBQ3JCLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQy9CLENBQ0YsQ0FBQztRQUVGLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQ3pCLElBQUksV0FBVyxFQUFFLENBQUMsTUFBTSxDQUFDLHNCQUFzQixDQUFDLENBQzVDLENBQUM7UUFFUCxPQUFPO1lBQ0wsOERBQThEO1lBQzlELFFBQVE7WUFDUix3REFBd0Q7WUFDeEQsSUFBSSxFQUFFLGNBQWM7U0FDckIsQ0FBQztLQUNIO0lBQUMsT0FBTyxLQUFVLEVBQUU7UUFDbkIsT0FBTyxDQUFDLEtBQUssQ0FDWCxxREFBcUQsRUFDckQsZ0JBQWdCLENBQ2pCLENBQUM7UUFDRixNQUFNLEtBQUssQ0FBQztLQUNiO0FBQ0gsQ0FBQyxFQUFDO0FBRUYsZ0ZBQWdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL2RhdGEvZW5jb2RlLnRzPzliOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmbGF0ZSwgaW5mbGF0ZSB9IGZyb20gXCJwYWtvXCI7XG5pbXBvcnQgeyBlbmNyeXB0RGF0YSwgZGVjcnlwdERhdGEgfSBmcm9tIFwiLi9lbmNyeXB0aW9uXCI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBieXRlIChiaW5hcnkpIHN0cmluZ3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIGZhc3QsIEJ1ZmZlci1jb21wYXRpYmxlIGltcGxlbVxuZXhwb3J0IGNvbnN0IHRvQnl0ZVN0cmluZyA9IChcbiAgZGF0YTogc3RyaW5nIHwgVWludDhBcnJheSB8IEFycmF5QnVmZmVyLFxuKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBibG9iID1cbiAgICAgIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiXG4gICAgICAgID8gbmV3IEJsb2IoW25ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKV0pXG4gICAgICAgIDogbmV3IEJsb2IoW2RhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gZGF0YSA6IG5ldyBVaW50OEFycmF5KGRhdGEpXSk7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWV2ZW50LnRhcmdldCB8fCB0eXBlb2YgZXZlbnQudGFyZ2V0LnJlc3VsdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcImNvdWxkbid0IGNvbnZlcnQgdG8gYnl0ZSBzdHJpbmdcIikpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICB9O1xuICAgIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcoYmxvYik7XG4gIH0pO1xufTtcblxuY29uc3QgYnl0ZVN0cmluZ1RvQXJyYXlCdWZmZXIgPSAoYnl0ZVN0cmluZzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IGJ1ZmZlclZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYnl0ZVN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZmZlclZpZXdbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbmNvbnN0IGJ5dGVTdHJpbmdUb1N0cmluZyA9IChieXRlU3RyaW5nOiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpLmRlY29kZShieXRlU3RyaW5nVG9BcnJheUJ1ZmZlcihieXRlU3RyaW5nKSk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gYmFzZTY0XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEBwYXJhbSBpc0J5dGVTdHJpbmcgc2V0IHRvIHRydWUgaWYgYWxyZWFkeSBieXRlIHN0cmluZyB0byBwcmV2ZW50IGJsb2F0XG4gKiAgZHVlIHRvIHJlZW5jb2RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ1RvQmFzZTY0ID0gYXN5bmMgKHN0cjogc3RyaW5nLCBpc0J5dGVTdHJpbmcgPSBmYWxzZSkgPT4ge1xuICByZXR1cm4gaXNCeXRlU3RyaW5nID8gd2luZG93LmJ0b2Eoc3RyKSA6IHdpbmRvdy5idG9hKGF3YWl0IHRvQnl0ZVN0cmluZyhzdHIpKTtcbn07XG5cbi8vIGFzeW5jIHRvIGFsaWduIHdpdGggc3RyaW5nVG9CYXNlNjRcbmV4cG9ydCBjb25zdCBiYXNlNjRUb1N0cmluZyA9IGFzeW5jIChiYXNlNjQ6IHN0cmluZywgaXNCeXRlU3RyaW5nID0gZmFsc2UpID0+IHtcbiAgcmV0dXJuIGlzQnl0ZVN0cmluZ1xuICAgID8gd2luZG93LmF0b2IoYmFzZTY0KVxuICAgIDogYnl0ZVN0cmluZ1RvU3RyaW5nKHdpbmRvdy5hdG9iKGJhc2U2NCkpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRleHQgZW5jb2Rpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnR5cGUgRW5jb2RlZERhdGEgPSB7XG4gIGVuY29kZWQ6IHN0cmluZztcbiAgZW5jb2Rpbmc6IFwiYnN0cmluZ1wiO1xuICAvKiogd2hldGhlciB0ZXh0IGlzIGNvbXByZXNzZWQgKHpsaWIpICovXG4gIGNvbXByZXNzZWQ6IGJvb2xlYW47XG4gIC8qKiB2ZXJzaW9uIGZvciBwb3RlbnRpYWwgbWlncmF0aW9uIHB1cnBvc2VzICovXG4gIHZlcnNpb24/OiBzdHJpbmc7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgKGFuZCBwb3RlbnRpYWxseSBjb21wcmVzc2VzIHZpYSB6bGliKSB0ZXh0IHRvIGJ5dGUgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGUgPSBhc3luYyAoe1xuICB0ZXh0LFxuICBjb21wcmVzcyxcbn06IHtcbiAgdGV4dDogc3RyaW5nO1xuICAvKiogZGVmYXVsdHMgdG8gYHRydWVgLiBJZiBjb21wcmVzc2lvbiBmYWlscywgZmFsbHMgYmFjayB0byBic3RyaW5nIGFsb25lLiAqL1xuICBjb21wcmVzcz86IGJvb2xlYW47XG59KTogUHJvbWlzZTxFbmNvZGVkRGF0YT4gPT4ge1xuICBsZXQgZGVmbGF0ZWQhOiBzdHJpbmc7XG4gIGlmIChjb21wcmVzcyAhPT0gZmFsc2UpIHtcbiAgICB0cnkge1xuICAgICAgZGVmbGF0ZWQgPSBhd2FpdCB0b0J5dGVTdHJpbmcoZGVmbGF0ZSh0ZXh0KSk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcImVuY29kZTogY2Fubm90IGRlZmxhdGVcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHZlcnNpb246IFwiMVwiLFxuICAgIGVuY29kaW5nOiBcImJzdHJpbmdcIixcbiAgICBjb21wcmVzc2VkOiAhIWRlZmxhdGVkLFxuICAgIGVuY29kZWQ6IGRlZmxhdGVkIHx8IChhd2FpdCB0b0J5dGVTdHJpbmcodGV4dCkpLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGRlY29kZSA9IGFzeW5jIChkYXRhOiBFbmNvZGVkRGF0YSk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIGxldCBkZWNvZGVkOiBzdHJpbmc7XG5cbiAgc3dpdGNoIChkYXRhLmVuY29kaW5nKSB7XG4gICAgY2FzZSBcImJzdHJpbmdcIjpcbiAgICAgIC8vIGlmIGNvbXByZXNzZWQsIGRvIG5vdCBkb3VibGUgZGVjb2RlIHRoZSBic3RyaW5nXG4gICAgICBkZWNvZGVkID0gZGF0YS5jb21wcmVzc2VkXG4gICAgICAgID8gZGF0YS5lbmNvZGVkXG4gICAgICAgIDogYXdhaXQgYnl0ZVN0cmluZ1RvU3RyaW5nKGRhdGEuZW5jb2RlZCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBkZWNvZGU6IHVua25vd24gZW5jb2RpbmcgXCIke2RhdGEuZW5jb2Rpbmd9XCJgKTtcbiAgfVxuXG4gIGlmIChkYXRhLmNvbXByZXNzZWQpIHtcbiAgICByZXR1cm4gaW5mbGF0ZShuZXcgVWludDhBcnJheShieXRlU3RyaW5nVG9BcnJheUJ1ZmZlcihkZWNvZGVkKSksIHtcbiAgICAgIHRvOiBcInN0cmluZ1wiLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gYmluYXJ5IGVuY29kaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG50eXBlIEZpbGVFbmNvZGluZ0luZm8gPSB7XG4gIC8qIHZlcnNpb24gMiBpcyB0aGUgdmVyc2lvbiB3ZSdyZSBzaGlwcGluZyB0aGUgaW5pdGlhbCBpbWFnZSBzdXBwb3J0IHdpdGguXG4gICAgdmVyc2lvbiAxIHdhcyBhIFBSIHZlcnNpb24gdGhhdCBhIGxvdCBvZiBwZW9wbGUgd2VyZSB1c2luZyBhbnl3YXkuXG4gICAgVGh1cywgaWYgdGhlcmUgYXJlIGlzc3VlcyB3ZSBjYW4gY2hlY2sgd2hldGhlciB0aGV5J3JlIG5vdCB1c2luZyB0aGVcbiAgICB1bm9mZmljIHZlcnNpb24gKi9cbiAgdmVyc2lvbjogMSB8IDI7XG4gIGNvbXByZXNzaW9uOiBcInBha29AMVwiIHwgbnVsbDtcbiAgZW5jcnlwdGlvbjogXCJBRVMtR0NNXCIgfCBudWxsO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IENPTkNBVF9CVUZGRVJTX1ZFUlNJT04gPSAxO1xuLyoqIGhvdyBtYW55IGJ5dGVzIHdlIHVzZSB0byBlbmNvZGUgaG93IG1hbnkgYnl0ZXMgdGhlIG5leHQgY2h1bmsgaGFzLlxuICogQ29ycmVzcG9uZHMgdG8gRGF0YVZpZXcgc2V0dGVyIG1ldGhvZHMgKHNldFVpbnQzMiwgc2V0VWludDE2LCBldGMpLlxuICpcbiAqIE5PVEUgISB2YWx1ZXMgbXVzdCBub3QgYmUgY2hhbmdlZCwgd2hpY2ggd291bGQgYmUgYmFja3dhcmRzIGluY29tcGF0aWJsZSAhXG4gKi9cbmNvbnN0IFZFUlNJT05fREFUQVZJRVdfQllURVMgPSA0O1xuY29uc3QgTkVYVF9DSFVOS19TSVpFX0RBVEFWSUVXX0JZVEVTID0gNDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERBVEFfVklFV19CSVRTX01BUCA9IHsgMTogOCwgMjogMTYsIDQ6IDMyIH0gYXMgY29uc3Q7XG5cbi8vIGdldHRlclxuZnVuY3Rpb24gZGF0YVZpZXcoYnVmZmVyOiBVaW50OEFycmF5LCBieXRlczogMSB8IDIgfCA0LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlcjtcbi8vIHNldHRlclxuZnVuY3Rpb24gZGF0YVZpZXcoXG4gIGJ1ZmZlcjogVWludDhBcnJheSxcbiAgYnl0ZXM6IDEgfCAyIHwgNCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHZhbHVlOiBudW1iZXIsXG4pOiBVaW50OEFycmF5O1xuLyoqXG4gKiBhYnN0cmFjdGlvbiBvdmVyIERhdGFWaWV3IHRoYXQgc2VydmVzIGFzIGEgdHlwZWQgZ2V0dGVyL3NldHRlciBpbiBjYXNlXG4gKiB5b3UncmUgdXNpbmcgY29uc3RhbnRzIGZvciB0aGUgYnl0ZSBzaXplIGFuZCB3YW50IHRvIGVuc3VyZSB0aGVyZSdzIG5vXG4gKiBkaXNjcmVwZW5hbmN5IGluIHRoZSBlbmNvZGluZyBhY3Jvc3MgcmVmYWN0b3JzLlxuICpcbiAqIERhdGFWaWV3IHNlcnZlcyBmb3IgYW4gZW5kaWFuLWFnbm9zdGljIGhhbmRsaW5nIG9mIG51bWJlcnMgaW4gQXJyYXlCdWZmZXJzLlxuICovXG5mdW5jdGlvbiBkYXRhVmlldyhcbiAgYnVmZmVyOiBVaW50OEFycmF5LFxuICBieXRlczogMSB8IDIgfCA0LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgdmFsdWU/OiBudW1iZXIsXG4pOiBVaW50OEFycmF5IHwgbnVtYmVyIHtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAodmFsdWUgPiBNYXRoLnBvdygyLCBEQVRBX1ZJRVdfQklUU19NQVBbYnl0ZXNdKSAtIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGF0dGVtcHRpbmcgdG8gc2V0IHZhbHVlIGhpZ2hlciB0aGFuIHRoZSBhbGxvY2F0ZWQgYnl0ZXMgKHZhbHVlOiAke3ZhbHVlfSwgYnl0ZXM6ICR7Ynl0ZXN9KWAsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBgc2V0VWludCR7REFUQV9WSUVXX0JJVFNfTUFQW2J5dGVzXX1gIGFzIGNvbnN0O1xuICAgIG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyKVttZXRob2RdKG9mZnNldCwgdmFsdWUpO1xuICAgIHJldHVybiBidWZmZXI7XG4gIH1cbiAgY29uc3QgbWV0aG9kID0gYGdldFVpbnQke0RBVEFfVklFV19CSVRTX01BUFtieXRlc119YCBhcyBjb25zdDtcbiAgcmV0dXJuIG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyKVttZXRob2RdKG9mZnNldCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogUmVzdWx0aW5nIGNvbmNhdGVuYXRlZCBidWZmZXIgaGFzIHRoaXMgZm9ybWF0OlxuICpcbiAqIFtcbiAqICAgVkVSU0lPTiBjaHVuayAoNCBieXRlcylcbiAqICAgTEVOR1RIIGNodW5rIDEgKDQgYnl0ZXMpXG4gKiAgIERBVEEgY2h1bmsgMSAodXAgdG8gMl4zMiBiaXRzKVxuICogICBMRU5HVEggY2h1bmsgMiAoNCBieXRlcylcbiAqICAgREFUQSBjaHVuayAyICh1cCB0byAyXjMyIGJpdHMpXG4gKiAgIC4uLlxuICogXVxuICpcbiAqIEBwYXJhbSBidWZmZXJzIGVhY2ggYnVmZmVyIChjaHVuaykgbXVzdCBiZSBhdCBtb3N0IDJeMzIgYml0cyBsYXJnZSAofjRHQilcbiAqL1xuY29uc3QgY29uY2F0QnVmZmVycyA9ICguLi5idWZmZXJzOiBVaW50OEFycmF5W10pID0+IHtcbiAgY29uc3QgYnVmZmVyVmlldyA9IG5ldyBVaW50OEFycmF5KFxuICAgIFZFUlNJT05fREFUQVZJRVdfQllURVMgK1xuICAgICAgTkVYVF9DSFVOS19TSVpFX0RBVEFWSUVXX0JZVEVTICogYnVmZmVycy5sZW5ndGggK1xuICAgICAgYnVmZmVycy5yZWR1Y2UoKGFjYywgYnVmZmVyKSA9PiBhY2MgKyBidWZmZXIuYnl0ZUxlbmd0aCwgMCksXG4gICk7XG5cbiAgbGV0IGN1cnNvciA9IDA7XG5cbiAgLy8gYXMgdGhlIGZpcnN0IGNodW5rIHdlJ2xsIGVuY29kZSB0aGUgdmVyc2lvbiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgZGF0YVZpZXcoYnVmZmVyVmlldywgVkVSU0lPTl9EQVRBVklFV19CWVRFUywgY3Vyc29yLCBDT05DQVRfQlVGRkVSU19WRVJTSU9OKTtcbiAgY3Vyc29yICs9IFZFUlNJT05fREFUQVZJRVdfQllURVM7XG5cbiAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgIGRhdGFWaWV3KFxuICAgICAgYnVmZmVyVmlldyxcbiAgICAgIE5FWFRfQ0hVTktfU0laRV9EQVRBVklFV19CWVRFUyxcbiAgICAgIGN1cnNvcixcbiAgICAgIGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICk7XG4gICAgY3Vyc29yICs9IE5FWFRfQ0hVTktfU0laRV9EQVRBVklFV19CWVRFUztcblxuICAgIGJ1ZmZlclZpZXcuc2V0KGJ1ZmZlciwgY3Vyc29yKTtcbiAgICBjdXJzb3IgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyVmlldztcbn07XG5cbi8qKiBjYW4gb25seSBiZSB1c2VkIG9uIGJ1ZmZlcnMgY3JlYXRlZCB2aWEgYGNvbmNhdEJ1ZmZlcnMoKWAgKi9cbmNvbnN0IHNwbGl0QnVmZmVycyA9IChjb25jYXRlbmF0ZWRCdWZmZXI6IFVpbnQ4QXJyYXkpID0+IHtcbiAgY29uc3QgYnVmZmVycyA9IFtdO1xuXG4gIGxldCBjdXJzb3IgPSAwO1xuXG4gIC8vIGZpcnN0IGNodW5rIGlzIHRoZSB2ZXJzaW9uXG4gIGNvbnN0IHZlcnNpb24gPSBkYXRhVmlldyhcbiAgICBjb25jYXRlbmF0ZWRCdWZmZXIsXG4gICAgTkVYVF9DSFVOS19TSVpFX0RBVEFWSUVXX0JZVEVTLFxuICAgIGN1cnNvcixcbiAgKTtcbiAgLy8gSWYgdmVyc2lvbiBpcyBvdXRzaWRlIG9mIHRoZSBzdXBwb3J0ZWQgdmVyc2lvbnMsIHRocm93IGFuIGVycm9yLlxuICAvLyBUaGlzIHVzdWFsbHkgbWVhbnMgdGhlIGJ1ZmZlciB3YXNuJ3QgZW5jb2RlZCB1c2luZyB0aGlzIEFQSSwgc28gd2UnZCBvbmx5XG4gIC8vIHdhc3RlIGNvbXB1dGUuXG4gIGlmICh2ZXJzaW9uID4gQ09OQ0FUX0JVRkZFUlNfVkVSU0lPTikge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbiAgfVxuXG4gIGN1cnNvciArPSBWRVJTSU9OX0RBVEFWSUVXX0JZVEVTO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgY2h1bmtTaXplID0gZGF0YVZpZXcoXG4gICAgICBjb25jYXRlbmF0ZWRCdWZmZXIsXG4gICAgICBORVhUX0NIVU5LX1NJWkVfREFUQVZJRVdfQllURVMsXG4gICAgICBjdXJzb3IsXG4gICAgKTtcbiAgICBjdXJzb3IgKz0gTkVYVF9DSFVOS19TSVpFX0RBVEFWSUVXX0JZVEVTO1xuXG4gICAgYnVmZmVycy5wdXNoKGNvbmNhdGVuYXRlZEJ1ZmZlci5zbGljZShjdXJzb3IsIGN1cnNvciArIGNodW5rU2l6ZSkpO1xuICAgIGN1cnNvciArPSBjaHVua1NpemU7XG4gICAgaWYgKGN1cnNvciA+PSBjb25jYXRlbmF0ZWRCdWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcnM7XG59O1xuXG4vLyBoZWxwZXJzIGZvciAoZGUpY29tcHJlc3NpbmcgZGF0YSB3aXRoIEpTT04gbWV0YWRhdGEgaW5jbHVkaW5nIGVuY3J5cHRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKiBAcHJpdmF0ZSAqL1xuY29uc3QgX2VuY3J5cHRBbmRDb21wcmVzcyA9IGFzeW5jIChcbiAgZGF0YTogVWludDhBcnJheSB8IHN0cmluZyxcbiAgZW5jcnlwdGlvbktleTogc3RyaW5nLFxuKSA9PiB7XG4gIGNvbnN0IHsgZW5jcnlwdGVkQnVmZmVyLCBpdiB9ID0gYXdhaXQgZW5jcnlwdERhdGEoXG4gICAgZW5jcnlwdGlvbktleSxcbiAgICBkZWZsYXRlKGRhdGEpLFxuICApO1xuXG4gIHJldHVybiB7IGl2LCBidWZmZXI6IG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZEJ1ZmZlcikgfTtcbn07XG5cbi8qKlxuICogVGhlIHJldHVybmVkIGJ1ZmZlciBoYXMgZm9sbG93aW5nIGZvcm1hdDpcbiAqIGBbXWAgcmVmZXJzIHRvIGEgYnVmZmVycyB3cmFwcGVyIChzZWUgYGNvbmNhdEJ1ZmZlcnNgKVxuICpcbiAqIFtcbiAqICAgZW5jb2RpbmdNZXRhZGF0YUJ1ZmZlcixcbiAqICAgaXYsXG4gKiAgIFtcbiAqICAgICAgY29udGVudHNNZXRhZGF0YUJ1ZmZlclxuICogICAgICBjb250ZW50c0J1ZmZlclxuICogICBdXG4gKiBdXG4gKi9cbmV4cG9ydCBjb25zdCBjb21wcmVzc0RhdGEgPSBhc3luYyA8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gPSBuZXZlcj4oXG4gIGRhdGFCdWZmZXI6IFVpbnQ4QXJyYXksXG4gIG9wdGlvbnM6IHtcbiAgICBlbmNyeXB0aW9uS2V5OiBzdHJpbmc7XG4gIH0gJiAoW1RdIGV4dGVuZHMgW25ldmVyXVxuICAgID8ge1xuICAgICAgICBtZXRhZGF0YT86IFQ7XG4gICAgICB9XG4gICAgOiB7XG4gICAgICAgIG1ldGFkYXRhOiBUO1xuICAgICAgfSksXG4pOiBQcm9taXNlPFVpbnQ4QXJyYXk+ID0+IHtcbiAgY29uc3QgZmlsZUluZm86IEZpbGVFbmNvZGluZ0luZm8gPSB7XG4gICAgdmVyc2lvbjogMixcbiAgICBjb21wcmVzc2lvbjogXCJwYWtvQDFcIixcbiAgICBlbmNyeXB0aW9uOiBcIkFFUy1HQ01cIixcbiAgfTtcblxuICBjb25zdCBlbmNvZGluZ01ldGFkYXRhQnVmZmVyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFxuICAgIEpTT04uc3RyaW5naWZ5KGZpbGVJbmZvKSxcbiAgKTtcblxuICBjb25zdCBjb250ZW50c01ldGFkYXRhQnVmZmVyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFxuICAgIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMubWV0YWRhdGEgfHwgbnVsbCksXG4gICk7XG5cbiAgY29uc3QgeyBpdiwgYnVmZmVyIH0gPSBhd2FpdCBfZW5jcnlwdEFuZENvbXByZXNzKFxuICAgIGNvbmNhdEJ1ZmZlcnMoY29udGVudHNNZXRhZGF0YUJ1ZmZlciwgZGF0YUJ1ZmZlciksXG4gICAgb3B0aW9ucy5lbmNyeXB0aW9uS2V5LFxuICApO1xuXG4gIHJldHVybiBjb25jYXRCdWZmZXJzKGVuY29kaW5nTWV0YWRhdGFCdWZmZXIsIGl2LCBidWZmZXIpO1xufTtcblxuLyoqIEBwcml2YXRlICovXG5jb25zdCBfZGVjcnlwdEFuZERlY29tcHJlc3MgPSBhc3luYyAoXG4gIGl2OiBVaW50OEFycmF5LFxuICBkZWNyeXB0ZWRCdWZmZXI6IFVpbnQ4QXJyYXksXG4gIGRlY3J5cHRpb25LZXk6IHN0cmluZyxcbiAgaXNDb21wcmVzc2VkOiBib29sZWFuLFxuKSA9PiB7XG4gIGRlY3J5cHRlZEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KFxuICAgIGF3YWl0IGRlY3J5cHREYXRhKGl2LCBkZWNyeXB0ZWRCdWZmZXIsIGRlY3J5cHRpb25LZXkpLFxuICApO1xuXG4gIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICByZXR1cm4gaW5mbGF0ZShkZWNyeXB0ZWRCdWZmZXIpO1xuICB9XG5cbiAgcmV0dXJuIGRlY3J5cHRlZEJ1ZmZlcjtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWNvbXByZXNzRGF0YSA9IGFzeW5jIDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4oXG4gIGJ1ZmZlclZpZXc6IFVpbnQ4QXJyYXksXG4gIG9wdGlvbnM6IHsgZGVjcnlwdGlvbktleTogc3RyaW5nIH0sXG4pID0+IHtcbiAgLy8gZmlyc3QgY2h1bmsgaXMgZW5jb2RpbmcgbWV0YWRhdGEgKGlnbm9yZWQgZm9yIG5vdylcbiAgY29uc3QgW2VuY29kaW5nTWV0YWRhdGFCdWZmZXIsIGl2LCBidWZmZXJdID0gc3BsaXRCdWZmZXJzKGJ1ZmZlclZpZXcpO1xuXG4gIGNvbnN0IGVuY29kaW5nTWV0YWRhdGE6IEZpbGVFbmNvZGluZ0luZm8gPSBKU09OLnBhcnNlKFxuICAgIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShlbmNvZGluZ01ldGFkYXRhQnVmZmVyKSxcbiAgKTtcblxuICB0cnkge1xuICAgIGNvbnN0IFtjb250ZW50c01ldGFkYXRhQnVmZmVyLCBjb250ZW50c0J1ZmZlcl0gPSBzcGxpdEJ1ZmZlcnMoXG4gICAgICBhd2FpdCBfZGVjcnlwdEFuZERlY29tcHJlc3MoXG4gICAgICAgIGl2LFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIG9wdGlvbnMuZGVjcnlwdGlvbktleSxcbiAgICAgICAgISFlbmNvZGluZ01ldGFkYXRhLmNvbXByZXNzaW9uLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgY29uc3QgbWV0YWRhdGEgPSBKU09OLnBhcnNlKFxuICAgICAgbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGNvbnRlbnRzTWV0YWRhdGFCdWZmZXIpLFxuICAgICkgYXMgVDtcblxuICAgIHJldHVybiB7XG4gICAgICAvKiogbWV0YWRhdGEgc291cmNlIGlzIGFsd2F5cyBKU09OIHNvIHdlIGNhbiBkZWNvZGUgaXQgaGVyZSAqL1xuICAgICAgbWV0YWRhdGEsXG4gICAgICAvKiogZGF0YSBjYW4gYmUgYW55dGhpbmcgc28gdGhlIGNhbGxlciBtdXN0IGRlY29kZSBpdCAqL1xuICAgICAgZGF0YTogY29udGVudHNCdWZmZXIsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgRXJyb3IgZHVyaW5nIGRlY29tcHJlc3NpbmcgYW5kIGRlY3J5cHRpbmcgdGhlIGZpbGUuYCxcbiAgICAgIGVuY29kaW5nTWV0YWRhdGEsXG4gICAgKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../data/encode.ts\n");

/***/ }),

/***/ "../../data/encryption.ts":
/*!********************************!*\
  !*** ../../data/encryption.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IV_LENGTH_BYTES\": () => (/* binding */ IV_LENGTH_BYTES),\n/* harmony export */   \"createIV\": () => (/* binding */ createIV),\n/* harmony export */   \"generateEncryptionKey\": () => (/* binding */ generateEncryptionKey),\n/* harmony export */   \"getCryptoKey\": () => (/* binding */ getCryptoKey),\n/* harmony export */   \"encryptData\": () => (/* binding */ encryptData),\n/* harmony export */   \"decryptData\": () => (/* binding */ decryptData)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ \"../../constants.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nconst IV_LENGTH_BYTES = 12;\nconst createIV = () => {\n    const arr = new Uint8Array(IV_LENGTH_BYTES);\n    return window.crypto.getRandomValues(arr);\n};\nconst generateEncryptionKey = (returnAs) => __awaiter(void 0, void 0, void 0, function* () {\n    const key = yield window.crypto.subtle.generateKey({\n        name: \"AES-GCM\",\n        length: _constants__WEBPACK_IMPORTED_MODULE_0__.ENCRYPTION_KEY_BITS,\n    }, true, // extractable\n    [\"encrypt\", \"decrypt\"]);\n    return (returnAs === \"cryptoKey\"\n        ? key\n        : (yield window.crypto.subtle.exportKey(\"jwk\", key)).k);\n});\nconst getCryptoKey = (key, usage) => window.crypto.subtle.importKey(\"jwk\", {\n    alg: \"A128GCM\",\n    ext: true,\n    k: key,\n    key_ops: [\"encrypt\", \"decrypt\"],\n    kty: \"oct\",\n}, {\n    name: \"AES-GCM\",\n    length: _constants__WEBPACK_IMPORTED_MODULE_0__.ENCRYPTION_KEY_BITS,\n}, false, // extractable\n[usage]);\nconst encryptData = (key, data) => __awaiter(void 0, void 0, void 0, function* () {\n    const importedKey = typeof key === \"string\" ? yield getCryptoKey(key, \"encrypt\") : key;\n    const iv = createIV();\n    const buffer = typeof data === \"string\"\n        ? new TextEncoder().encode(data)\n        : data instanceof Uint8Array\n            ? data\n            : data instanceof Blob\n                ? yield data.arrayBuffer()\n                : data;\n    // We use symmetric encryption. AES-GCM is the recommended algorithm and\n    // includes checks that the ciphertext has not been modified by an attacker.\n    const encryptedBuffer = yield window.crypto.subtle.encrypt({\n        name: \"AES-GCM\",\n        iv,\n    }, importedKey, buffer);\n    return { encryptedBuffer, iv };\n});\nconst decryptData = (iv, encrypted, privateKey) => __awaiter(void 0, void 0, void 0, function* () {\n    const key = yield getCryptoKey(privateKey, \"decrypt\");\n    return window.crypto.subtle.decrypt({\n        name: \"AES-GCM\",\n        iv,\n    }, key, encrypted);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQ3RELE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUNqQztRQUNFLElBQUksRUFBRSxTQUFTO1FBQ2YsRUFBRTtLQUNILEVBQ0QsR0FBRyxFQUNILFNBQVMsQ0FDVixDQUFDO0FBQ0osQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL2RhdGEvZW5jcnlwdGlvbi50cz9hZDMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVOQ1JZUFRJT05fS0VZX0JJVFMgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBjb25zdCBJVl9MRU5HVEhfQllURVMgPSAxMjtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUlWID0gKCkgPT4ge1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShJVl9MRU5HVEhfQllURVMpO1xuICByZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUVuY3J5cHRpb25LZXkgPSBhc3luYyA8XG4gIFQgZXh0ZW5kcyBcInN0cmluZ1wiIHwgXCJjcnlwdG9LZXlcIiA9IFwic3RyaW5nXCIsXG4+KFxuICByZXR1cm5Bcz86IFQsXG4pOiBQcm9taXNlPFQgZXh0ZW5kcyBcImNyeXB0b0tleVwiID8gQ3J5cHRvS2V5IDogc3RyaW5nPiA9PiB7XG4gIGNvbnN0IGtleSA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KFxuICAgIHtcbiAgICAgIG5hbWU6IFwiQUVTLUdDTVwiLFxuICAgICAgbGVuZ3RoOiBFTkNSWVBUSU9OX0tFWV9CSVRTLFxuICAgIH0sXG4gICAgdHJ1ZSwgLy8gZXh0cmFjdGFibGVcbiAgICBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXSxcbiAgKTtcbiAgcmV0dXJuIChcbiAgICByZXR1cm5BcyA9PT0gXCJjcnlwdG9LZXlcIlxuICAgICAgPyBrZXlcbiAgICAgIDogKGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmV4cG9ydEtleShcImp3a1wiLCBrZXkpKS5rXG4gICkgYXMgVCBleHRlbmRzIFwiY3J5cHRvS2V5XCIgPyBDcnlwdG9LZXkgOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q3J5cHRvS2V5ID0gKGtleTogc3RyaW5nLCB1c2FnZTogS2V5VXNhZ2UpID0+XG4gIHdpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICBcImp3a1wiLFxuICAgIHtcbiAgICAgIGFsZzogXCJBMTI4R0NNXCIsXG4gICAgICBleHQ6IHRydWUsXG4gICAgICBrOiBrZXksXG4gICAgICBrZXlfb3BzOiBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXSxcbiAgICAgIGt0eTogXCJvY3RcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiQUVTLUdDTVwiLFxuICAgICAgbGVuZ3RoOiBFTkNSWVBUSU9OX0tFWV9CSVRTLFxuICAgIH0sXG4gICAgZmFsc2UsIC8vIGV4dHJhY3RhYmxlXG4gICAgW3VzYWdlXSxcbiAgKTtcblxuZXhwb3J0IGNvbnN0IGVuY3J5cHREYXRhID0gYXN5bmMgKFxuICBrZXk6IHN0cmluZyB8IENyeXB0b0tleSxcbiAgZGF0YTogVWludDhBcnJheSB8IEFycmF5QnVmZmVyIHwgQmxvYiB8IEZpbGUgfCBzdHJpbmcsXG4pOiBQcm9taXNlPHsgZW5jcnlwdGVkQnVmZmVyOiBBcnJheUJ1ZmZlcjsgaXY6IFVpbnQ4QXJyYXkgfT4gPT4ge1xuICBjb25zdCBpbXBvcnRlZEtleSA9XG4gICAgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiA/IGF3YWl0IGdldENyeXB0b0tleShrZXksIFwiZW5jcnlwdFwiKSA6IGtleTtcbiAgY29uc3QgaXYgPSBjcmVhdGVJVigpO1xuICBjb25zdCBidWZmZXI6IEFycmF5QnVmZmVyIHwgVWludDhBcnJheSA9XG4gICAgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGEpXG4gICAgICA6IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICA/IGRhdGFcbiAgICAgIDogZGF0YSBpbnN0YW5jZW9mIEJsb2JcbiAgICAgID8gYXdhaXQgZGF0YS5hcnJheUJ1ZmZlcigpXG4gICAgICA6IGRhdGE7XG5cbiAgLy8gV2UgdXNlIHN5bW1ldHJpYyBlbmNyeXB0aW9uLiBBRVMtR0NNIGlzIHRoZSByZWNvbW1lbmRlZCBhbGdvcml0aG0gYW5kXG4gIC8vIGluY2x1ZGVzIGNoZWNrcyB0aGF0IHRoZSBjaXBoZXJ0ZXh0IGhhcyBub3QgYmVlbiBtb2RpZmllZCBieSBhbiBhdHRhY2tlci5cbiAgY29uc3QgZW5jcnlwdGVkQnVmZmVyID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZW5jcnlwdChcbiAgICB7XG4gICAgICBuYW1lOiBcIkFFUy1HQ01cIixcbiAgICAgIGl2LFxuICAgIH0sXG4gICAgaW1wb3J0ZWRLZXksXG4gICAgYnVmZmVyIGFzIEFycmF5QnVmZmVyIHwgVWludDhBcnJheSxcbiAgKTtcblxuICByZXR1cm4geyBlbmNyeXB0ZWRCdWZmZXIsIGl2IH07XG59O1xuXG5leHBvcnQgY29uc3QgZGVjcnlwdERhdGEgPSBhc3luYyAoXG4gIGl2OiBVaW50OEFycmF5LFxuICBlbmNyeXB0ZWQ6IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlcixcbiAgcHJpdmF0ZUtleTogc3RyaW5nLFxuKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4gPT4ge1xuICBjb25zdCBrZXkgPSBhd2FpdCBnZXRDcnlwdG9LZXkocHJpdmF0ZUtleSwgXCJkZWNyeXB0XCIpO1xuICByZXR1cm4gd2luZG93LmNyeXB0by5zdWJ0bGUuZGVjcnlwdChcbiAgICB7XG4gICAgICBuYW1lOiBcIkFFUy1HQ01cIixcbiAgICAgIGl2LFxuICAgIH0sXG4gICAga2V5LFxuICAgIGVuY3J5cHRlZCxcbiAgKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../data/encryption.ts\n");

/***/ }),

/***/ "../../data/image.ts":
/*!***************************!*\
  !*** ../../data/image.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getTEXtChunk\": () => (/* binding */ getTEXtChunk),\n/* harmony export */   \"encodePngMetadata\": () => (/* binding */ encodePngMetadata),\n/* harmony export */   \"decodePngMetadata\": () => (/* binding */ decodePngMetadata),\n/* harmony export */   \"encodeSvgMetadata\": () => (/* binding */ encodeSvgMetadata),\n/* harmony export */   \"decodeSvgMetadata\": () => (/* binding */ decodeSvgMetadata)\n/* harmony export */ });\n/* harmony import */ var png_chunks_extract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! png-chunks-extract */ \"../../../node_modules/png-chunks-extract/index.js\");\n/* harmony import */ var png_chunks_extract__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(png_chunks_extract__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var png_chunk_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! png-chunk-text */ \"../../../node_modules/png-chunk-text/index.js\");\n/* harmony import */ var png_chunks_encode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! png-chunks-encode */ \"../../../node_modules/png-chunks-encode/index.js\");\n/* harmony import */ var png_chunks_encode__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(png_chunks_encode__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _encode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./encode */ \"../../data/encode.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ \"../../constants.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n// -----------------------------------------------------------------------------\n// PNG\n// -----------------------------------------------------------------------------\nconst blobToArrayBuffer = (blob) => {\n    if (\"arrayBuffer\" in blob) {\n        return blob.arrayBuffer();\n    }\n    // Safari\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (event) => {\n            var _a;\n            if (!((_a = event.target) === null || _a === void 0 ? void 0 : _a.result)) {\n                return reject(new Error(\"couldn't convert blob to ArrayBuffer\"));\n            }\n            resolve(event.target.result);\n        };\n        reader.readAsArrayBuffer(blob);\n    });\n};\nconst getTEXtChunk = (blob) => __awaiter(void 0, void 0, void 0, function* () {\n    const chunks = png_chunks_extract__WEBPACK_IMPORTED_MODULE_0___default()(new Uint8Array(yield blobToArrayBuffer(blob)));\n    const metadataChunk = chunks.find((chunk) => chunk.name === \"tEXt\");\n    if (metadataChunk) {\n        return png_chunk_text__WEBPACK_IMPORTED_MODULE_1__.decode(metadataChunk.data);\n    }\n    return null;\n});\nconst encodePngMetadata = ({ blob, metadata, }) => __awaiter(void 0, void 0, void 0, function* () {\n    const chunks = png_chunks_extract__WEBPACK_IMPORTED_MODULE_0___default()(new Uint8Array(yield blobToArrayBuffer(blob)));\n    const metadataChunk = png_chunk_text__WEBPACK_IMPORTED_MODULE_1__.encode(_constants__WEBPACK_IMPORTED_MODULE_4__.MIME_TYPES.excalidraw, JSON.stringify(yield (0,_encode__WEBPACK_IMPORTED_MODULE_3__.encode)({\n        text: metadata,\n        compress: true,\n    })));\n    // insert metadata before last chunk (iEND)\n    chunks.splice(-1, 0, metadataChunk);\n    return new Blob([png_chunks_encode__WEBPACK_IMPORTED_MODULE_2___default()(chunks)], { type: _constants__WEBPACK_IMPORTED_MODULE_4__.MIME_TYPES.png });\n});\nconst decodePngMetadata = (blob) => __awaiter(void 0, void 0, void 0, function* () {\n    const metadata = yield getTEXtChunk(blob);\n    if ((metadata === null || metadata === void 0 ? void 0 : metadata.keyword) === _constants__WEBPACK_IMPORTED_MODULE_4__.MIME_TYPES.excalidraw) {\n        try {\n            const encodedData = JSON.parse(metadata.text);\n            if (!(\"encoded\" in encodedData)) {\n                // legacy, un-encoded scene JSON\n                if (\"type\" in encodedData &&\n                    encodedData.type === _constants__WEBPACK_IMPORTED_MODULE_4__.EXPORT_DATA_TYPES.excalidraw) {\n                    return metadata.text;\n                }\n                throw new Error(\"FAILED\");\n            }\n            return yield (0,_encode__WEBPACK_IMPORTED_MODULE_3__.decode)(encodedData);\n        }\n        catch (error) {\n            console.error(error);\n            throw new Error(\"FAILED\");\n        }\n    }\n    throw new Error(\"INVALID\");\n});\n// -----------------------------------------------------------------------------\n// SVG\n// -----------------------------------------------------------------------------\nconst encodeSvgMetadata = ({ text }) => __awaiter(void 0, void 0, void 0, function* () {\n    const base64 = yield (0,_encode__WEBPACK_IMPORTED_MODULE_3__.stringToBase64)(JSON.stringify(yield (0,_encode__WEBPACK_IMPORTED_MODULE_3__.encode)({ text })), true /* is already byte string */);\n    let metadata = \"\";\n    metadata += `<!-- payload-type:${_constants__WEBPACK_IMPORTED_MODULE_4__.MIME_TYPES.excalidraw} -->`;\n    metadata += `<!-- payload-version:2 -->`;\n    metadata += \"<!-- payload-start -->\";\n    metadata += base64;\n    metadata += \"<!-- payload-end -->\";\n    return metadata;\n});\nconst decodeSvgMetadata = ({ svg }) => __awaiter(void 0, void 0, void 0, function* () {\n    if (svg.includes(`payload-type:${_constants__WEBPACK_IMPORTED_MODULE_4__.MIME_TYPES.excalidraw}`)) {\n        const match = svg.match(/<!-- payload-start -->(.+?)<!-- payload-end -->/);\n        if (!match) {\n            throw new Error(\"INVALID\");\n        }\n        const versionMatch = svg.match(/<!-- payload-version:(\\d+) -->/);\n        const version = (versionMatch === null || versionMatch === void 0 ? void 0 : versionMatch[1]) || \"1\";\n        const isByteString = version !== \"1\";\n        try {\n            const json = yield (0,_encode__WEBPACK_IMPORTED_MODULE_3__.base64ToString)(match[1], isByteString);\n            const encodedData = JSON.parse(json);\n            if (!(\"encoded\" in encodedData)) {\n                // legacy, un-encoded scene JSON\n                if (\"type\" in encodedData &&\n                    encodedData.type === _constants__WEBPACK_IMPORTED_MODULE_4__.EXPORT_DATA_TYPES.excalidraw) {\n                    return json;\n                }\n                throw new Error(\"FAILED\");\n            }\n            return yield (0,_encode__WEBPACK_IMPORTED_MODULE_3__.decode)(encodedData);\n        }\n        catch (error) {\n            console.error(error);\n            throw new Error(\"FAILED\");\n        }\n    }\n    throw new Error(\"INVALID\");\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vZGF0YS9pbWFnZS50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDVDtBQUNRO0FBQ2dDO0FBQ2I7QUFFN0QsZ0ZBQWdGO0FBQ2hGLE1BQU07QUFDTixnRkFBZ0Y7QUFFaEYsTUFBTSxpQkFBaUIsR0FBRyxDQUFDLElBQVUsRUFBd0IsRUFBRTtJQUM3RCxJQUFJLGFBQWEsSUFBSSxJQUFJLEVBQUU7UUFDekIsT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDM0I7SUFDRCxTQUFTO0lBQ1QsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtRQUNyQyxNQUFNLE1BQU0sR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO1FBQ2hDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRTs7WUFDeEIsSUFBSSxDQUFDLFlBQUssQ0FBQyxNQUFNLDBDQUFFLE1BQU0sR0FBRTtnQkFDekIsT0FBTyxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQyxDQUFDO2FBQ2xFO1lBQ0QsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBcUIsQ0FBQyxDQUFDO1FBQzlDLENBQUMsQ0FBQztRQUNGLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNqQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQztBQUVLLE1BQU0sWUFBWSxHQUFHLENBQzFCLElBQVUsRUFDeUMsRUFBRTtJQUNyRCxNQUFNLE1BQU0sR0FBRyx5REFBUyxDQUFDLElBQUksVUFBVSxDQUFDLE1BQU0saUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hFLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLENBQUM7SUFDcEUsSUFBSSxhQUFhLEVBQUU7UUFDakIsT0FBTyxrREFBVyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN4QztJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyxFQUFDO0FBRUssTUFBTSxpQkFBaUIsR0FBRyxDQUFPLEVBQ3RDLElBQUksRUFDSixRQUFRLEdBSVQsRUFBRSxFQUFFO0lBQ0gsTUFBTSxNQUFNLEdBQUcseURBQVMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV4RSxNQUFNLGFBQWEsR0FBRyxrREFBVyxDQUMvQiw2REFBcUIsRUFDckIsSUFBSSxDQUFDLFNBQVMsQ0FDWixNQUFNLCtDQUFNLENBQUM7UUFDWCxJQUFJLEVBQUUsUUFBUTtRQUNkLFFBQVEsRUFBRSxJQUFJO0tBQ2YsQ0FBQyxDQUNILENBQ0YsQ0FBQztJQUNGLDJDQUEyQztJQUMzQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUVwQyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsd0RBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLHNEQUFjLEVBQUUsQ0FBQyxDQUFDO0FBQ2pFLENBQUMsRUFBQztBQUVLLE1BQU0saUJBQWlCLEdBQUcsQ0FBTyxJQUFVLEVBQUUsRUFBRTtJQUNwRCxNQUFNLFFBQVEsR0FBRyxNQUFNLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQyxJQUFJLFNBQVEsYUFBUixRQUFRLHVCQUFSLFFBQVEsQ0FBRSxPQUFPLE1BQUssNkRBQXFCLEVBQUU7UUFDL0MsSUFBSTtZQUNGLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzlDLElBQUksQ0FBQyxDQUFDLFNBQVMsSUFBSSxXQUFXLENBQUMsRUFBRTtnQkFDL0IsZ0NBQWdDO2dCQUNoQyxJQUNFLE1BQU0sSUFBSSxXQUFXO29CQUNyQixXQUFXLENBQUMsSUFBSSxLQUFLLG9FQUE0QixFQUNqRDtvQkFDQSxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUM7aUJBQ3RCO2dCQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDM0I7WUFDRCxPQUFPLE1BQU0sK0NBQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUNsQztRQUFDLE9BQU8sS0FBVSxFQUFFO1lBQ25CLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUMzQjtLQUNGO0lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUM3QixDQUFDLEVBQUM7QUFFRixnRkFBZ0Y7QUFDaEYsTUFBTTtBQUNOLGdGQUFnRjtBQUV6RSxNQUFNLGlCQUFpQixHQUFHLENBQU8sRUFBRSxJQUFJLEVBQW9CLEVBQUUsRUFBRTtJQUNwRSxNQUFNLE1BQU0sR0FBRyxNQUFNLHVEQUFjLENBQ2pDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSwrQ0FBTSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUN0QyxJQUFJLENBQUMsNEJBQTRCLENBQ2xDLENBQUM7SUFFRixJQUFJLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDbEIsUUFBUSxJQUFJLHFCQUFxQiw2REFBcUIsTUFBTSxDQUFDO0lBQzdELFFBQVEsSUFBSSw0QkFBNEIsQ0FBQztJQUN6QyxRQUFRLElBQUksd0JBQXdCLENBQUM7SUFDckMsUUFBUSxJQUFJLE1BQU0sQ0FBQztJQUNuQixRQUFRLElBQUksc0JBQXNCLENBQUM7SUFDbkMsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQyxFQUFDO0FBRUssTUFBTSxpQkFBaUIsR0FBRyxDQUFPLEVBQUUsR0FBRyxFQUFtQixFQUFFLEVBQUU7SUFDbEUsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLGdCQUFnQiw2REFBcUIsRUFBRSxDQUFDLEVBQUU7UUFDekQsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO1FBQzNFLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDVixNQUFNLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzVCO1FBQ0QsTUFBTSxZQUFZLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1FBQ2pFLE1BQU0sT0FBTyxHQUFHLGFBQVksYUFBWixZQUFZLHVCQUFaLFlBQVksQ0FBRyxDQUFDLENBQUMsS0FBSSxHQUFHLENBQUM7UUFDekMsTUFBTSxZQUFZLEdBQUcsT0FBTyxLQUFLLEdBQUcsQ0FBQztRQUVyQyxJQUFJO1lBQ0YsTUFBTSxJQUFJLEdBQUcsTUFBTSx1REFBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUMxRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3JDLElBQUksQ0FBQyxDQUFDLFNBQVMsSUFBSSxXQUFXLENBQUMsRUFBRTtnQkFDL0IsZ0NBQWdDO2dCQUNoQyxJQUNFLE1BQU0sSUFBSSxXQUFXO29CQUNyQixXQUFXLENBQUMsSUFBSSxLQUFLLG9FQUE0QixFQUNqRDtvQkFDQSxPQUFPLElBQUksQ0FBQztpQkFDYjtnQkFDRCxNQUFNLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQzNCO1lBQ0QsT0FBTyxNQUFNLCtDQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDbEM7UUFBQyxPQUFPLEtBQVUsRUFBRTtZQUNuQixPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDM0I7S0FDRjtJQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDN0IsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL2RhdGEvaW1hZ2UudHM/MjUwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVjb2RlUG5nIGZyb20gXCJwbmctY2h1bmtzLWV4dHJhY3RcIjtcbmltcG9ydCB0RVh0IGZyb20gXCJwbmctY2h1bmstdGV4dFwiO1xuaW1wb3J0IGVuY29kZVBuZyBmcm9tIFwicG5nLWNodW5rcy1lbmNvZGVcIjtcbmltcG9ydCB7IHN0cmluZ1RvQmFzZTY0LCBlbmNvZGUsIGRlY29kZSwgYmFzZTY0VG9TdHJpbmcgfSBmcm9tIFwiLi9lbmNvZGVcIjtcbmltcG9ydCB7IEVYUE9SVF9EQVRBX1RZUEVTLCBNSU1FX1RZUEVTIH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUE5HXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBibG9iVG9BcnJheUJ1ZmZlciA9IChibG9iOiBCbG9iKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4gPT4ge1xuICBpZiAoXCJhcnJheUJ1ZmZlclwiIGluIGJsb2IpIHtcbiAgICByZXR1cm4gYmxvYi5hcnJheUJ1ZmZlcigpO1xuICB9XG4gIC8vIFNhZmFyaVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZCA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKCFldmVudC50YXJnZXQ/LnJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcImNvdWxkbid0IGNvbnZlcnQgYmxvYiB0byBBcnJheUJ1ZmZlclwiKSk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQgYXMgQXJyYXlCdWZmZXIpO1xuICAgIH07XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRURVh0Q2h1bmsgPSBhc3luYyAoXG4gIGJsb2I6IEJsb2IsXG4pOiBQcm9taXNlPHsga2V5d29yZDogc3RyaW5nOyB0ZXh0OiBzdHJpbmcgfSB8IG51bGw+ID0+IHtcbiAgY29uc3QgY2h1bmtzID0gZGVjb2RlUG5nKG5ldyBVaW50OEFycmF5KGF3YWl0IGJsb2JUb0FycmF5QnVmZmVyKGJsb2IpKSk7XG4gIGNvbnN0IG1ldGFkYXRhQ2h1bmsgPSBjaHVua3MuZmluZCgoY2h1bmspID0+IGNodW5rLm5hbWUgPT09IFwidEVYdFwiKTtcbiAgaWYgKG1ldGFkYXRhQ2h1bmspIHtcbiAgICByZXR1cm4gdEVYdC5kZWNvZGUobWV0YWRhdGFDaHVuay5kYXRhKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBlbmNvZGVQbmdNZXRhZGF0YSA9IGFzeW5jICh7XG4gIGJsb2IsXG4gIG1ldGFkYXRhLFxufToge1xuICBibG9iOiBCbG9iO1xuICBtZXRhZGF0YTogc3RyaW5nO1xufSkgPT4ge1xuICBjb25zdCBjaHVua3MgPSBkZWNvZGVQbmcobmV3IFVpbnQ4QXJyYXkoYXdhaXQgYmxvYlRvQXJyYXlCdWZmZXIoYmxvYikpKTtcblxuICBjb25zdCBtZXRhZGF0YUNodW5rID0gdEVYdC5lbmNvZGUoXG4gICAgTUlNRV9UWVBFUy5leGNhbGlkcmF3LFxuICAgIEpTT04uc3RyaW5naWZ5KFxuICAgICAgYXdhaXQgZW5jb2RlKHtcbiAgICAgICAgdGV4dDogbWV0YWRhdGEsXG4gICAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgfSksXG4gICAgKSxcbiAgKTtcbiAgLy8gaW5zZXJ0IG1ldGFkYXRhIGJlZm9yZSBsYXN0IGNodW5rIChpRU5EKVxuICBjaHVua3Muc3BsaWNlKC0xLCAwLCBtZXRhZGF0YUNodW5rKTtcblxuICByZXR1cm4gbmV3IEJsb2IoW2VuY29kZVBuZyhjaHVua3MpXSwgeyB0eXBlOiBNSU1FX1RZUEVTLnBuZyB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWNvZGVQbmdNZXRhZGF0YSA9IGFzeW5jIChibG9iOiBCbG9iKSA9PiB7XG4gIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgZ2V0VEVYdENodW5rKGJsb2IpO1xuICBpZiAobWV0YWRhdGE/LmtleXdvcmQgPT09IE1JTUVfVFlQRVMuZXhjYWxpZHJhdykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IEpTT04ucGFyc2UobWV0YWRhdGEudGV4dCk7XG4gICAgICBpZiAoIShcImVuY29kZWRcIiBpbiBlbmNvZGVkRGF0YSkpIHtcbiAgICAgICAgLy8gbGVnYWN5LCB1bi1lbmNvZGVkIHNjZW5lIEpTT05cbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwidHlwZVwiIGluIGVuY29kZWREYXRhICYmXG4gICAgICAgICAgZW5jb2RlZERhdGEudHlwZSA9PT0gRVhQT1JUX0RBVEFfVFlQRVMuZXhjYWxpZHJhd1xuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gbWV0YWRhdGEudGV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGQUlMRURcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgZGVjb2RlKGVuY29kZWREYXRhKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZBSUxFRFwiKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRFwiKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTVkdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBlbmNvZGVTdmdNZXRhZGF0YSA9IGFzeW5jICh7IHRleHQgfTogeyB0ZXh0OiBzdHJpbmcgfSkgPT4ge1xuICBjb25zdCBiYXNlNjQgPSBhd2FpdCBzdHJpbmdUb0Jhc2U2NChcbiAgICBKU09OLnN0cmluZ2lmeShhd2FpdCBlbmNvZGUoeyB0ZXh0IH0pKSxcbiAgICB0cnVlIC8qIGlzIGFscmVhZHkgYnl0ZSBzdHJpbmcgKi8sXG4gICk7XG5cbiAgbGV0IG1ldGFkYXRhID0gXCJcIjtcbiAgbWV0YWRhdGEgKz0gYDwhLS0gcGF5bG9hZC10eXBlOiR7TUlNRV9UWVBFUy5leGNhbGlkcmF3fSAtLT5gO1xuICBtZXRhZGF0YSArPSBgPCEtLSBwYXlsb2FkLXZlcnNpb246MiAtLT5gO1xuICBtZXRhZGF0YSArPSBcIjwhLS0gcGF5bG9hZC1zdGFydCAtLT5cIjtcbiAgbWV0YWRhdGEgKz0gYmFzZTY0O1xuICBtZXRhZGF0YSArPSBcIjwhLS0gcGF5bG9hZC1lbmQgLS0+XCI7XG4gIHJldHVybiBtZXRhZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWNvZGVTdmdNZXRhZGF0YSA9IGFzeW5jICh7IHN2ZyB9OiB7IHN2Zzogc3RyaW5nIH0pID0+IHtcbiAgaWYgKHN2Zy5pbmNsdWRlcyhgcGF5bG9hZC10eXBlOiR7TUlNRV9UWVBFUy5leGNhbGlkcmF3fWApKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBzdmcubWF0Y2goLzwhLS0gcGF5bG9hZC1zdGFydCAtLT4oLis/KTwhLS0gcGF5bG9hZC1lbmQgLS0+Lyk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRFwiKTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbk1hdGNoID0gc3ZnLm1hdGNoKC88IS0tIHBheWxvYWQtdmVyc2lvbjooXFxkKykgLS0+Lyk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25NYXRjaD8uWzFdIHx8IFwiMVwiO1xuICAgIGNvbnN0IGlzQnl0ZVN0cmluZyA9IHZlcnNpb24gIT09IFwiMVwiO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCBiYXNlNjRUb1N0cmluZyhtYXRjaFsxXSwgaXNCeXRlU3RyaW5nKTtcbiAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgIGlmICghKFwiZW5jb2RlZFwiIGluIGVuY29kZWREYXRhKSkge1xuICAgICAgICAvLyBsZWdhY3ksIHVuLWVuY29kZWQgc2NlbmUgSlNPTlxuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJ0eXBlXCIgaW4gZW5jb2RlZERhdGEgJiZcbiAgICAgICAgICBlbmNvZGVkRGF0YS50eXBlID09PSBFWFBPUlRfREFUQV9UWVBFUy5leGNhbGlkcmF3XG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZBSUxFRFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCBkZWNvZGUoZW5jb2RlZERhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRkFJTEVEXCIpO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEXCIpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../data/image.ts\n");

/***/ })

}]);